name: Deploy ECS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: Target environment
        required: true
        type: choice
        options:
          - sandbox
          - production
        default: sandbox
      task_definition_arn:
        description: Optional task definition ARN/revision to deploy (leave blank to force new deployment)
        required: false
        type: string
        default: ""

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-${{ inputs.environment }}
  cancel-in-progress: false

jobs:
  preflight:
    name: Preflight Gate
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}

      - name: Resolve environment config
        id: resolve
        shell: bash
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SUBNETS: ${{ vars.ECS_SUBNETS }}
          ECS_SECURITY_GROUPS: ${{ vars.ECS_SECURITY_GROUPS }}
          TASKDEF_SANDBOX: ${{ vars.ECS_BACKEND_TASKDEF_SANDBOX }}
          TASKDEF_PRODUCTION: ${{ vars.ECS_BACKEND_TASKDEF_PRODUCTION }}
        run: |
          set -euo pipefail

          TARGET_ENV="${{ inputs.environment }}"
          if [[ "$TARGET_ENV" == "production" ]]; then
            TASKDEF="${TASKDEF_PRODUCTION}"
            PROBE_LLM="true"
          else
            TASKDEF="${TASKDEF_SANDBOX}"
            PROBE_LLM="false"
          fi

          : "${TASKDEF:?Missing task definition variable for target env}"
          : "${ECS_CLUSTER:?Missing vars.ECS_CLUSTER}"
          : "${ECS_SUBNETS:?Missing vars.ECS_SUBNETS}"
          : "${ECS_SECURITY_GROUPS:?Missing vars.ECS_SECURITY_GROUPS}"

          echo "taskdef=$TASKDEF" >> "$GITHUB_OUTPUT"
          echo "target_env=$TARGET_ENV" >> "$GITHUB_OUTPUT"
          echo "probe_llm=$PROBE_LLM" >> "$GITHUB_OUTPUT"

      - name: Run ECS preflight task
        id: run_preflight
        shell: bash
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SUBNETS: ${{ vars.ECS_SUBNETS }}
          ECS_SECURITY_GROUPS: ${{ vars.ECS_SECURITY_GROUPS }}
          ECS_ASSIGN_PUBLIC_IP: ${{ vars.ECS_ASSIGN_PUBLIC_IP }}
          CONTAINER_NAME: ${{ vars.ECS_BACKEND_CONTAINER_NAME }}
        run: |
          set -euo pipefail

          assign_public_ip="${ECS_ASSIGN_PUBLIC_IP:-DISABLED}"
          container_name="${CONTAINER_NAME:-backend}"

          subnets_json="$(printf '%s' "${ECS_SUBNETS}" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$"; "")) | map(select(length > 0))')"
          security_groups_json="$(printf '%s' "${ECS_SECURITY_GROUPS}" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$"; "")) | map(select(length > 0))')"

          network_json="$(
            jq -n \
              --argjson subnets "${subnets_json}" \
              --argjson security_groups "${security_groups_json}" \
              --arg assign_public_ip "${assign_public_ip}" \
              '{awsvpcConfiguration: {subnets: $subnets, securityGroups: $security_groups, assignPublicIp: $assign_public_ip}}'
          )"

          overrides_json="$(
            jq -n \
              --arg container_name "${container_name}" \
              --arg expected_mode "${{ steps.resolve.outputs.target_env }}" \
              --arg probe_llm "${{ steps.resolve.outputs.probe_llm }}" \
              '{
                containerOverrides: [
                  {
                    name: $container_name,
                    command: (
                      ["python", "-m", "scripts.preflight", "--expected-mode", $expected_mode, "--probe-embedding"] +
                      (if $probe_llm == "true" then ["--probe-llm"] else [] end) +
                      ["--json"]
                    )
                  }
                ]
              }'
          )"

          task_arn="$(
            aws ecs run-task \
              --cluster "${ECS_CLUSTER}" \
              --task-definition "${{ steps.resolve.outputs.taskdef }}" \
              --launch-type FARGATE \
              --count 1 \
              --network-configuration "${network_json}" \
              --overrides "${overrides_json}" \
              --query 'tasks[0].taskArn' \
              --output text
          )"

          echo "task_arn=${task_arn}" >> "$GITHUB_OUTPUT"
          echo "Preflight task ARN: ${task_arn}"

          aws ecs wait tasks-stopped --cluster "${ECS_CLUSTER}" --tasks "${task_arn}"

          exit_code="$(
            aws ecs describe-tasks \
              --cluster "${ECS_CLUSTER}" \
              --tasks "${task_arn}" \
              --query "tasks[0].containers[?name=='${container_name}'].exitCode | [0]" \
              --output text
          )"

          stop_reason="$(
            aws ecs describe-tasks \
              --cluster "${ECS_CLUSTER}" \
              --tasks "${task_arn}" \
              --query 'tasks[0].stoppedReason' \
              --output text
          )"

          echo "Preflight task stopped reason: ${stop_reason}"
          echo "Preflight container exit code: ${exit_code}"

          if [[ "${exit_code}" != "0" ]]; then
            echo "Preflight failed. Deployment blocked."
            exit 1
          fi

  deploy:
    name: Deploy Service
    runs-on: ubuntu-latest
    needs: preflight
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}

      - name: Resolve service config
        id: resolve
        shell: bash
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          SERVICE_SANDBOX: ${{ vars.ECS_BACKEND_SERVICE_SANDBOX }}
          SERVICE_PRODUCTION: ${{ vars.ECS_BACKEND_SERVICE_PRODUCTION }}
        run: |
          set -euo pipefail

          TARGET_ENV="${{ inputs.environment }}"
          if [[ "$TARGET_ENV" == "production" ]]; then
            SERVICE_NAME="${SERVICE_PRODUCTION}"
          else
            SERVICE_NAME="${SERVICE_SANDBOX}"
          fi

          : "${SERVICE_NAME:?Missing ECS service name variable for target env}"
          : "${ECS_CLUSTER:?Missing vars.ECS_CLUSTER}"

          echo "service_name=$SERVICE_NAME" >> "$GITHUB_OUTPUT"

      - name: Deploy backend service
        shell: bash
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
        run: |
          set -euo pipefail

          if [[ -n "${{ inputs.task_definition_arn }}" ]]; then
            aws ecs update-service \
              --cluster "${ECS_CLUSTER}" \
              --service "${{ steps.resolve.outputs.service_name }}" \
              --task-definition "${{ inputs.task_definition_arn }}"
          else
            aws ecs update-service \
              --cluster "${ECS_CLUSTER}" \
              --service "${{ steps.resolve.outputs.service_name }}" \
              --force-new-deployment
          fi
